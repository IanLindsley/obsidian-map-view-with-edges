import * as leaflet from 'leaflet';

// import '@fortawesome/fontawesome-free/js/all.min';
import { fas } from '@fortawesome/free-solid-svg-icons';
import { far } from '@fortawesome/free-regular-svg-icons';
import { fab } from '@fortawesome/free-brands-svg-icons';
import {
    library,
    IconPrefix,
    IconName,
    config as faConfig,
    findIconDefinition,
    icon as faIcon,
} from '@fortawesome/fontawesome-svg-core';

import 'leaflet-extra-markers';
import 'leaflet-extra-markers/dist/css/leaflet.extra-markers.min.css';
// Ugly hack for obsidian-leaflet compatability, see https://github.com/esm7/obsidian-map-view/issues/6
// @ts-ignore
let localL = L;
import wildcard from 'wildcard';

import { MarkerIconRule } from 'src/settings';

export function getIconFromRules(
    tags: string[],
    rules: MarkerIconRule[],
    iconFactory: IconFactory
) {
    // We iterate over the rules and apply them one by one, so later rules override earlier ones
    let shape = null;
    let result = rules.find((item) => item.ruleName === 'default').iconDetails;
    for (const rule of rules) {
        if (checkTagPatternMatch(rule.ruleName, tags)) {
            result = Object.assign({}, result, rule.iconDetails);
            shape = rule.iconDetails.shape;
        }
    }
    return getIconFromOptions(result, iconFactory, shape);
}

export function getIconFromOptions(
    iconSpec: leaflet.ExtraMarkers.IconOptions,
    iconFactory: IconFactory,
    shape: any = null
): leaflet.Icon | leaflet.DivIcon {
    // Ugly hack for obsidian-leaflet compatability, see https://github.com/esm7/obsidian-map-view/issues/6
    // @ts-ignore
    const backupL = L;
    try {
        // @ts-ignore
        L = localL;
        // We check for iconSpec.icon to allow a custom innerHTML specification for some rules,
        // and in such a case, do not wish to override the innerHTML by the icon rendition. See getIconFromRules above
        if (iconSpec.icon) {
        // If the shape is set to resizable-circle we will draw the circle marker itself. This makes it
        // possible to resize the marker (make it grow or shrink) based on the number of edges (lines)
        // connected to a given node. Otherwise, we let leaflet.ExtraMarkers handle the drawing of marker
        // icons.
          if (shape === 'resizable-circle') {
              return createCircleMarker(iconSpec.markerColor, [
                iconSpec.icon,
                iconSpec.prefix,
            ]) else if (isFontAwesome(iconSpec.icon)) {
                // The behavior of Leaflet Extra Markers is to render Font Awesome with Web Fonts & CSS, which has
                // proven too slow for displaying hundreds of markers.
                // This overrides the HTML generated by Extra Market to use the SVG Symbols alternative, which
                // seems much faster.
                // See here for more details: https://fontawesome.com/v5/docs/web/advanced/svg-symbols
                iconSpec.innerHTML = iconFactory.getIcon(iconSpec).outerHTML;
            } else if (isText(iconSpec.icon)) {
                // Emoji or other short textual icon
                const color = iconSpec.iconColor ?? 'white';
                iconSpec.innerHTML = `<p class="mv-emoji-icon" style="color:${color}">${iconSpec.icon}</p>`;
            }
        }
        return leaflet.ExtraMarkers.icon(iconSpec);
    } finally {
        // @ts-ignore
        L = backupL;
    }
}

export function createCircleMarkerBasedOnDegree(
    color: string = 'red',
    iconClasses: string[] = ['fas', 'fa-person'],
    degree: number = 0,
    degrees: number[] = []
): leaflet.DivIcon {
    let size = 20;
    let anchor = 10;
    let step = degrees.length <= 5 ? 1 : Math.ceil(degrees.length / 5);
    for (let i = step - 1; i < degrees.length; i += step) {
        if (degree <= degrees[i]) {
            // we found the correct bucket/percentile
            break;
        }
        size += 4;
        anchor += 2;
    }
    return createCircleMarker(color, iconClasses, size, anchor);
}

export function createCircleMarker(
    color: string = 'red',
    iconClasses: string[] = ['fas', 'fa-person'],
    iconSize: number = 30,
    iconAnchor: number = 15
): leaflet.DivIcon {
    let circleStyle = `
        background-color: ${color ?? 'red'};
        width: ${iconSize}px;
        height: ${iconSize}px;
    `;
    let fontSize = Math.ceil(iconSize * 0.66);
    let circleIcon = leaflet.divIcon({
        className: '', // Disable default Leaflet icon styles
        html: `<div class="resizable-circle-marker" style="${circleStyle}"><i style="font-size: ${fontSize}px;" class="${iconClasses.join(
            ' '
        )}"></i></div>`,
        iconSize: [iconSize, iconSize],
        iconAnchor: [iconAnchor, iconAnchor],
    });
    return circleIcon;
}
  
function isFontAwesome(iconName: string) {
    if (iconName.startsWith('fa-')) return true;
}

function isText(iconName: string) {
    return iconName.length <= 2;
}

// Utilizes the SVG capabilities of Font Awesome to generate icons, instead of using Web Fonts.
// Since we create the SVGs directly where they are needed, we can affort to turn off the slow
// Font Awesome MutationObserver, see the issue here: https://github.com/esm7/obsidian-map-view/issues/216
export class IconFactory {
    constructor(containerEl: HTMLElement) {
        faConfig.observeMutations = false;
        faConfig.autoReplaceSvg = false;
        library.add(fas, far, fab);
    }

    getIcon(iconSpec: leaflet.ExtraMarkers.IconOptions): SVGElement {
        const iconName = iconSpec.icon.replace('fa-', '') as IconName;
        const newIconDef = findIconDefinition({
            prefix: iconSpec.prefix as IconPrefix,
            iconName: iconName,
        });
        if (!newIconDef) return null;
        const newIcon = faIcon(newIconDef);
        if (!newIcon) return null;
        const iconNode = newIcon.node[0] as SVGElement;
        iconNode.style.color = iconSpec.iconColor ?? 'white';
        return iconNode;
    }
}

export function checkTagPatternMatch(tagPattern: string, tags: string[]) {
    let match = wildcard(tagPattern, tags);
    return match && match.length > 0;
}
